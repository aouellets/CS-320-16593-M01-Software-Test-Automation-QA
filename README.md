# CS-320-16593-M01-Software-Test-Automation-QA

# **CS 320 Portfolio Submission - Software Testing and Quality Assurance**

## **Overview**
This repository contains selected artifacts from CS 320, showcasing my skills in software testing, automation, and quality assurance. The files included are essential parts of two main projects developed throughout the course. These projects demonstrate my proficiency in creating unit tests, analyzing software testing approaches, and applying strategies to meet software requirements.

## **Included Files**

### **Project One: Contact Service**
- **Contact.java** - Defines the `Contact` class, which includes properties and constraints for managing contact details.
- **ContactService.java** - Implements the `ContactService` class to add, update, and delete contacts.
- **ContactTest.java** - Contains unit tests for the `Contact` class, ensuring data integrity and validation.
- **ContactServiceTest.java** - Contains unit tests for the `ContactService` class, verifying that service methods work as intended.

### **Project Two: Summary and Reflections Report**
- **Summary and Reflections Report** - A reflective report on the unit testing approach, effectiveness, and the testing strategies employed in both projects. This report also discusses the evolution of software testing and the mindset required for effective quality assurance.

---

## **Reflection**

### **1. Ensuring Functional and Secure Code**
To ensure that my code is functional and secure, I incorporate robust testing and adhere to coding best practices. For each feature, I wrote unit tests that cover both common and edge cases. These tests verify that all methods handle expected inputs correctly and throw errors for invalid ones. By integrating automated tests and following best practices in validation, I can confidently assess the functionality and security of my code. Continuous testing throughout development helps catch potential bugs and vulnerabilities early.

### **2. Interpreting User Needs and Incorporating Them into a Program**
Understanding and interpreting user needs is essential to delivering a program that meets requirements. For each project, I carefully analyzed the requirements to identify core functionalities and constraints, like field lengths, unique identifiers, and valid data ranges. By breaking down these needs into actionable requirements, I ensured that the code meets user expectations. Regular reflection on requirements also allows me to refine the code and enhance its usability.

### **3. Approach to Software Design**
When approaching software design, I start by defining clear objectives based on user requirements. I design the softwareâ€™s structure to separate concerns, making the code modular and easier to maintain. For example, by creating separate classes for `Contact` and `ContactService`, I ensure that each class has a single responsibility, which simplifies testing and future updates. After defining the structure, I write tests to validate each component individually, ensuring that the final software is reliable and flexible.
